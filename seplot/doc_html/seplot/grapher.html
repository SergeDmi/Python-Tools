<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>seplot.grapher API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>seplot.grapher</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from numpy import *
import sys
import sio_tools as sio
import pandas as pd


from seplot.styler import Style
import seplot.kw_dictionaries as kd
import seplot.style_dictionaries as sd


&#34;&#34;&#34;
Grapher is a sub-module defining the class Graph.
&#34;&#34;&#34;


# Basic set of colours, symbols, and lines
csl=sd.get_colors_symbols_lines()
colours=csl[&#39;colours&#39;]
colour_strings=csl[&#39;colour_strings&#39;]
symbols=csl[&#39;symbols&#39;]
linests=csl[&#39;linests&#39;]
# dictionaries
dicos=sd.get_dictionaries()
col_dict=dicos[&#39;colors&#39;]
linst_dict=dicos[&#39;lines&#39;]
symst_dict=dicos[&#39;symbols&#39;]
linw_dict=dicos[&#39;widths&#39;]
grad_dict=dicos[&#39;gradients&#39;]
kw_dict=kd.get_keywords()


class Graph:
    &#34;&#34;&#34;
    Graph is a class containing a single line/set of points and their style, created from class Toplot.
    &#34;&#34;&#34;
    def __init__(self,*args,
                x=0,y=1,dx=[],dy=[],col=&#39;&#39;,siz=&#39;&#39;,stil=&#39;&#39;,labels=[],
                cond=[],range=[],
                function_string=&#39;&#39;,legend=&#39;&#39;,
                fname=&#39;&#39;,data=None,numr=0,mode=&#39;v&#39;,
                n_points=&#39;200&#39;,
                **kwargs):
        &#34;&#34;&#34; Instance initialization &#34;&#34;&#34;


        self.fname=fname ; self.function_string=function_string
        #self.data=array(data)
        #self.data=array([])
        self.numr=numr
        self.mode=mode ; self.numr=numr
        self.dX=[] ; self.dY=[]
        self.X=[] ; self.Y=[] ; self.S=[] ; self.C=[]
        self.is_function=0
        self.is_histogram=0
        self.make_histogram=0
        self.xlabel=None ; self.ylabel=None

        self.range=range
        self.set_n_points(n_points)
        self.label_dict={}
        self.color_from_data=False
        self.legend=None
        self.path=None
        self.stroke_style=None

        self.make_auto_legend(legend)


        if self.function_string:
            self.is_function=1
        else:
            if data is not None:

                if isinstance(data, list):
                    data = ndarray(data)
                if isinstance(data, ndarray):

                    s = data.shape

                    if len(s)&lt;2:
                        data = ndarray([data])
                        s = data.shape

                    if not len(labels):
                        labels = [None]*s[1]
                    in_data = { &#34;data&#34; : data, &#34;size_x&#34; : s[0] , &#34;size_y&#34; : s[1] , &#34;labels&#34;: labels }

                if isinstance(data, pd.DataFrame):
                    in_data = sio.import_array_from_frames(data)

            else:
                in_data=sio.data_import_wrapper(self.fname)

            try:
                A=in_data[&#39;data&#39;]
                self.data=A
            except:
                raise ValueError(&#34;Error : no suitable data, nor function given&#34;)

            # Dirty tricks for maximum compatibility
            if min(in_data[&#39;size_x&#39;],in_data[&#39;size_y&#39;])==1:
                x=&#39;auto&#39;
                y=0
                sio.custom_warn(&#34;Single data row/column : x is automatic&#34;)
            if in_data[&#39;size_x&#39;]==1:
                self.mode=&#39;h&#39;

            # This is if we are dealing with (hopefuly) numeric data

            labels=in_data[&#39;labels&#39;]
            if self.mode==&#39;v&#39;:
                ncols=A.shape[1]
            else:
                ncols=A.shape[0]

            if len(labels)&lt;=ncols:
                self.labels=in_data[&#39;labels&#39;]


            for i,label in enumerate(self.labels):
                self.label_dict[label]=i

        # Are we plotting a histogram ?
        for arg in args:
            if arg.startswith(&#39;-hist&#39;):
                self.is_histogram=1
                self.make_histogram=1
                if not stil:
                    stil=&#39;B&#39;
                elif not (stil==&#39;b&#39; or stil==&#39;B&#39;):
                    sio.custom_warn(&#39;Forcing style to histogram&#39;)


        if not self.is_function:
            if not self.make_histogram:
                # This is if we are dealing with (hopefuly) numeric data
                #if (len(self.range) or len(cond)):
                if len(range):
                    A=self.set_A_range(A,range)
                # Set X Y to start with
                self.set_init_XY(A)
                # We perform a first extraction of X and Y to be able to evalyate conditions on X,Y
                self.X=self.set_from_input(A,x,&#39;x&#39;)
                self.Y=self.set_from_input(A,y,&#39;y&#39;)
                self.dX=self.set_from_input(A,dx,&#39;dx&#39;)
                self.dY=self.set_from_input(A,dy,&#39;dy&#39;)

                #if (len(self.range) or len(cond)):
                if len(cond):
                    A=self.set_A_condition(A,cond)
                # Set X Y to start with
                self.set_init_XY(A)
                # Now we perform the definitive extraction of X,Y once A has been filtered
                self.X=self.set_from_input(A,x,&#39;x&#39;)
                self.Y=self.set_from_input(A,y,&#39;y&#39;)
                self.dX=self.set_from_input(A,dx,&#39;dx&#39;)
                self.dY=self.set_from_input(A,dy,&#39;dy&#39;)

                # Now we assign colors and size if need be
                #if siz.isdigit() or siz.find(&#39;A[&#39;)&gt;=0:
                self.S=self.set_from_input(A,siz,&#39;size&#39;)
                #if col.isdigit() or col.find(&#39;A[&#39;)&gt;=0:
                self.C=self.set_from_input(A,col,&#39;color&#39;)
                if len(self.C):
                    if not var(self.C)&lt;sys.float_info.epsilon:
                        self.color_from_data=True
                    else:
                        sio.custom_warn(&#34;No variance in color provided, using random color based on mean value !&#34;)
                        col=colour_strings[int(mean(self.C)) %7]
                        self.C=[]
                    #print(&#34;Set color from data&#34;)

            else:
                # We&#39;re making a histogram !
                self.X=self.set_from_input(A,y,&#39;y&#39;)
                if len(cond):
                    A=self.set_A_condition(A,cond)
                self.Y=self.set_from_input(A,y,&#39;y&#39;)
                bin_number=0
                try:
                    bin_number=int(x)
                    if not bin_number==0:
                        try:
                            (self.Y,self.X)=get_histogram(self.Y,bins=bin_number)
                        except:
                            raise ValueError(&#39;Could not make histogram with data Y=%s and bins=%s (assumed bin number)&#39;  %(y,x) )
                    else:
                        (self.Y,self.X)=get_histogram(self.Y,bins=&#39;auto&#39;)
                except:
                    try:
                        bins=sio.make_array_from_str(x)
                        #print(bins)
                        if len(bins):
                            try:
                                #(self.Y,self.X)=get_histogram(self.Y,bins=bins)
                                (self.Y,self.X)=histogram(self.Y,bins)
                            except:
                                raise ValueError(&#39;Could not make histogram with data Y=%s and bins=%s (assumed array)&#39;  %(y,bins) )
                    except:
                        try:
                            (self.Y,self.X)=get_histogram(self.Y,bins=x)
                        except:
                            raise ValueError(&#39;Could not make histogram with data Y=%s and bins=%s (assumed text or other)&#39;  %(y,x) )
                #print(self.X)
                #print(self.Y)

            try:
                if not len(self.C):
                    self.C=self.X
            except:
                self.C=self.X

            try:
                if not len(self.S):
                    self.S=self.X
            except:
                self.S=self.X

            # We check size
            lX=len(self.X)
            lY=len(self.Y)
            if lX&gt;lY:
                self.X=self.X[0:lY]
                lX=lY
            elif lY&gt;lX:
                self.Y=self.Y[0:lX]
                lY=lX
            if not len(self.dY):
                self.dY=zeros((lX,1))
            if not len(self.dX):
                self.dX=zeros((lX,1))

            # we scale the color scale
            self.C=(self.C-min(self.C))/(max(self.C)-min(self.C))

            # we make sure no size is non-positive
            if min(self.S)&lt;=0:
                self.S=(self.S-min(self.S))+0.001

        # and now we can make the style !
        kwargs[&#39;col&#39;]=col ; kwargs[&#39;siz&#39;]=siz ; kwargs[&#39;is_function&#39;]=self.is_function
        kwargs[&#39;numr&#39;]=self.numr ; kwargs[&#39;dx&#39;]=dx ; kwargs[&#39;dy&#39;]=dy ; kwargs[&#39;stil&#39;]=stil
        kwargs[&#39;color_from_data&#39;]=self.color_from_data
        #kwargs[&#39;is_histogram&#39;]=self.is_histogram

        style=Style(*args,**kwargs)
        self.style=style.style
        self.stroke_style=style.stroke_style

        if style.goodstyle.kind==&#39;histogram&#39;:
            self.is_histogram=1

        #if self.is_histogram:
            #self.stroke=Style(*args,**kwargs).style
            #self.stroke_style=style.stroke_style

             #self.stroke_style=Style(*args,**kwargs.style)

    def make_auto_legend(self,legend):
        &#34;&#34;&#34; A function to automatically make a legend &#34;&#34;&#34;
        if legend==&#39;None&#39; or legend==&#39;none&#39;:
            self.legend=None
        elif legend:
            self.legend=r&#34;%s&#34; %legend
        else:
            if self.function_string:
                self.legend=self.function_string
            elif self.fname:
                lenf=len(self.fname)
                if lenf&lt;=16:
                    self.legend=self.fname
            else:
                self.legend=None

    def set_init_XY(self,A):
        &#34;&#34;&#34; Initial values of X and Y, usefull to later apply conditions &#34;&#34;&#34;
        try:
            if self.mode==&#39;h&#39;:
                self.X=A[0,:]
                self.Y=A[1,:]
            else:
                self.X=A[:,0]
                self.Y=A[:,1]
        except:
            sio.custom_warn(&#39;Could not set initial X Y values before reading arguments&#39;)
        return

    def set_n_points(self,arg):
        self.n_points=200
        try:
            self.n_points=int(arg)
        except:
            raise ValueError(&#39;Did not understand npoints from input %s&#39;  %arg)

    def set_label(self,label,coord):
        &#34;&#34;&#34; sets a label for coordinate x or y &#34;&#34;&#34;
        if coord==&#39;x&#39;:
            self.xlabel=label
        elif coord==&#39;y&#39;:
            self.ylabel=label
        return

    def set_from_input(self,A,input,coord):
        &#34;&#34;&#34; Tries to compute a variable of name coord from an input, usually a string or number, using the data A&#34;&#34;&#34;
        # We first check if axis defined by a row/column number
        X=self.X;x=X
        Y=self.Y;y=Y

        if input in self.labels:
            input=self.label_dict[input]

        try :
            i=int(input)
            if self.mode==&#39;h&#39;:
                # We try auto-setting the label if no label is defined
                if i&lt;len(self.labels):
                    self.set_label(self.labels[i],coord)
                return A[i,:]
            else:
                if i&lt;len(self.labels):
                    self.set_label(self.labels[i],coord)
                return A[:,i]
        except:
            if input:
                # Automatic axis value : 1 to length of array
                if input.startswith(&#39;aut&#39;):
                    if self.mode==&#39;h&#39;:
                        return array(range(len(A[0,:])))
                    else:
                        return array(range(len(A[:,0])))
                # Interpreting axis value
                for label in self.labels:
                    # trying to substitute label to array values
                    if input.find(label)&gt;=0:
                        input=self.substitute_label(input,A,label)
                try:
                    return eval(input)
                except:
                    if not coord==&#34;color&#34;:
                        raise ValueError(&#39;We could note evaluate %s from %s&#39; %(coord,input))
                    else:
                        sio.custom_warn(&#39;We might not be able to evaluate %s from %s&#39; %(coord,input))
                    return []
            else:
                return []

    def substitute_label(self,input,A,label):
        &#34;&#34;&#34; Substitutes names by values&#34;&#34;&#34;
        i=self.label_dict[label]
        if self.mode==&#39;h&#39;:
            replace=&#39;A[%s,:]&#39; %i
        else:
            replace=&#39;A[:,%s]&#39; %i
        return input.replace(label,replace)

    def set_A_range(self,A,in_range):
        &#34;&#34;&#34; Selects only a range of data &#34;&#34;&#34;
        # first we need to make data horizontal for the range operation
        if self.mode==&#39;h&#39;:
            B=A.transpose()
        else:
            B=A.copy()
        if len(in_range)&gt;0:
            srange=in_range.split(&#34;:&#34;)
            lr=len(srange)
            try :
                iii=array([int(s) for s in srange])
                if lr==1:
                    B=array([B[iii[0]]])
                elif lr==2:
                    B=B[iii[0]:iii[1]]
                elif lr==3:
                    B=B[iii[0]:iii[2]:iii[1]]
                else:
                    #print(&#39;Range must be of the format begin:end or begin:range&#39;)
                    raise ValueError(&#39;Range must be of the format begin:end or begin:step:end&#39;)
            except:
                raise ValueError(&#39;Cannot convert Range to adequate format (note : range must be of the format begin:end or begin:step:end)&#39;)
        if self.mode==&#39;h&#39;:
            A=B.transpose()
        else:
            A=B.copy()

        return A


    def set_A_condition(self,A,cond):
        &#34;&#34;&#34; Selects data by condition &#34;&#34;&#34;
        if self.mode==&#39;h&#39;:
            B=A.transpose()
        else:
            B=A.copy()

        if len(cond)&gt;0:
            X=self.X;x=X
            Y=self.Y;y=Y
            try:
                kept=eval(cond)
                if self.mode==&#39;h&#39;:
                    B=B[kept]
                    A=B.transpose()
                else:
                    A=A[kept]
            except:
                raise ValueError(&#39;Cannot understand condition. Hint use : if=\&#39;A[:,2]&gt;0.5\&#39; &#39;)

        return A



def get_histogram(Y,bins=&#39;auto&#39;):
    &#34;&#34;&#34; A wrapper for numpy&#39;s histogram &#34;&#34;&#34;
    (Y,X)=histogram(Y,bins)
    nx=len(X)
    if nx:
        X=(X[0:(nx-1)]+X[1:nx])/2.0
    else:
        raise ValueError(&#39;Empty histogram from numpy.histogram&#39;)
    return (Y,X)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="seplot.grapher.get_histogram"><code class="name flex">
<span>def <span class="ident">get_histogram</span></span>(<span>Y, bins='auto')</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper for numpy's histogram</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_histogram(Y,bins=&#39;auto&#39;):
    &#34;&#34;&#34; A wrapper for numpy&#39;s histogram &#34;&#34;&#34;
    (Y,X)=histogram(Y,bins)
    nx=len(X)
    if nx:
        X=(X[0:(nx-1)]+X[1:nx])/2.0
    else:
        raise ValueError(&#39;Empty histogram from numpy.histogram&#39;)
    return (Y,X)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="seplot.grapher.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>*args, x=0, y=1, dx=[], dy=[], col='', siz='', stil='', labels=[], cond=[], range=[], function_string='', legend='', fname='', data=None, numr=0, mode='v', n_points='200', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Graph is a class containing a single line/set of points and their style, created from class Toplot.</p>
<p>Instance initialization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph:
    &#34;&#34;&#34;
    Graph is a class containing a single line/set of points and their style, created from class Toplot.
    &#34;&#34;&#34;
    def __init__(self,*args,
                x=0,y=1,dx=[],dy=[],col=&#39;&#39;,siz=&#39;&#39;,stil=&#39;&#39;,labels=[],
                cond=[],range=[],
                function_string=&#39;&#39;,legend=&#39;&#39;,
                fname=&#39;&#39;,data=None,numr=0,mode=&#39;v&#39;,
                n_points=&#39;200&#39;,
                **kwargs):
        &#34;&#34;&#34; Instance initialization &#34;&#34;&#34;


        self.fname=fname ; self.function_string=function_string
        #self.data=array(data)
        #self.data=array([])
        self.numr=numr
        self.mode=mode ; self.numr=numr
        self.dX=[] ; self.dY=[]
        self.X=[] ; self.Y=[] ; self.S=[] ; self.C=[]
        self.is_function=0
        self.is_histogram=0
        self.make_histogram=0
        self.xlabel=None ; self.ylabel=None

        self.range=range
        self.set_n_points(n_points)
        self.label_dict={}
        self.color_from_data=False
        self.legend=None
        self.path=None
        self.stroke_style=None

        self.make_auto_legend(legend)


        if self.function_string:
            self.is_function=1
        else:
            if data is not None:

                if isinstance(data, list):
                    data = ndarray(data)
                if isinstance(data, ndarray):

                    s = data.shape

                    if len(s)&lt;2:
                        data = ndarray([data])
                        s = data.shape

                    if not len(labels):
                        labels = [None]*s[1]
                    in_data = { &#34;data&#34; : data, &#34;size_x&#34; : s[0] , &#34;size_y&#34; : s[1] , &#34;labels&#34;: labels }

                if isinstance(data, pd.DataFrame):
                    in_data = sio.import_array_from_frames(data)

            else:
                in_data=sio.data_import_wrapper(self.fname)

            try:
                A=in_data[&#39;data&#39;]
                self.data=A
            except:
                raise ValueError(&#34;Error : no suitable data, nor function given&#34;)

            # Dirty tricks for maximum compatibility
            if min(in_data[&#39;size_x&#39;],in_data[&#39;size_y&#39;])==1:
                x=&#39;auto&#39;
                y=0
                sio.custom_warn(&#34;Single data row/column : x is automatic&#34;)
            if in_data[&#39;size_x&#39;]==1:
                self.mode=&#39;h&#39;

            # This is if we are dealing with (hopefuly) numeric data

            labels=in_data[&#39;labels&#39;]
            if self.mode==&#39;v&#39;:
                ncols=A.shape[1]
            else:
                ncols=A.shape[0]

            if len(labels)&lt;=ncols:
                self.labels=in_data[&#39;labels&#39;]


            for i,label in enumerate(self.labels):
                self.label_dict[label]=i

        # Are we plotting a histogram ?
        for arg in args:
            if arg.startswith(&#39;-hist&#39;):
                self.is_histogram=1
                self.make_histogram=1
                if not stil:
                    stil=&#39;B&#39;
                elif not (stil==&#39;b&#39; or stil==&#39;B&#39;):
                    sio.custom_warn(&#39;Forcing style to histogram&#39;)


        if not self.is_function:
            if not self.make_histogram:
                # This is if we are dealing with (hopefuly) numeric data
                #if (len(self.range) or len(cond)):
                if len(range):
                    A=self.set_A_range(A,range)
                # Set X Y to start with
                self.set_init_XY(A)
                # We perform a first extraction of X and Y to be able to evalyate conditions on X,Y
                self.X=self.set_from_input(A,x,&#39;x&#39;)
                self.Y=self.set_from_input(A,y,&#39;y&#39;)
                self.dX=self.set_from_input(A,dx,&#39;dx&#39;)
                self.dY=self.set_from_input(A,dy,&#39;dy&#39;)

                #if (len(self.range) or len(cond)):
                if len(cond):
                    A=self.set_A_condition(A,cond)
                # Set X Y to start with
                self.set_init_XY(A)
                # Now we perform the definitive extraction of X,Y once A has been filtered
                self.X=self.set_from_input(A,x,&#39;x&#39;)
                self.Y=self.set_from_input(A,y,&#39;y&#39;)
                self.dX=self.set_from_input(A,dx,&#39;dx&#39;)
                self.dY=self.set_from_input(A,dy,&#39;dy&#39;)

                # Now we assign colors and size if need be
                #if siz.isdigit() or siz.find(&#39;A[&#39;)&gt;=0:
                self.S=self.set_from_input(A,siz,&#39;size&#39;)
                #if col.isdigit() or col.find(&#39;A[&#39;)&gt;=0:
                self.C=self.set_from_input(A,col,&#39;color&#39;)
                if len(self.C):
                    if not var(self.C)&lt;sys.float_info.epsilon:
                        self.color_from_data=True
                    else:
                        sio.custom_warn(&#34;No variance in color provided, using random color based on mean value !&#34;)
                        col=colour_strings[int(mean(self.C)) %7]
                        self.C=[]
                    #print(&#34;Set color from data&#34;)

            else:
                # We&#39;re making a histogram !
                self.X=self.set_from_input(A,y,&#39;y&#39;)
                if len(cond):
                    A=self.set_A_condition(A,cond)
                self.Y=self.set_from_input(A,y,&#39;y&#39;)
                bin_number=0
                try:
                    bin_number=int(x)
                    if not bin_number==0:
                        try:
                            (self.Y,self.X)=get_histogram(self.Y,bins=bin_number)
                        except:
                            raise ValueError(&#39;Could not make histogram with data Y=%s and bins=%s (assumed bin number)&#39;  %(y,x) )
                    else:
                        (self.Y,self.X)=get_histogram(self.Y,bins=&#39;auto&#39;)
                except:
                    try:
                        bins=sio.make_array_from_str(x)
                        #print(bins)
                        if len(bins):
                            try:
                                #(self.Y,self.X)=get_histogram(self.Y,bins=bins)
                                (self.Y,self.X)=histogram(self.Y,bins)
                            except:
                                raise ValueError(&#39;Could not make histogram with data Y=%s and bins=%s (assumed array)&#39;  %(y,bins) )
                    except:
                        try:
                            (self.Y,self.X)=get_histogram(self.Y,bins=x)
                        except:
                            raise ValueError(&#39;Could not make histogram with data Y=%s and bins=%s (assumed text or other)&#39;  %(y,x) )
                #print(self.X)
                #print(self.Y)

            try:
                if not len(self.C):
                    self.C=self.X
            except:
                self.C=self.X

            try:
                if not len(self.S):
                    self.S=self.X
            except:
                self.S=self.X

            # We check size
            lX=len(self.X)
            lY=len(self.Y)
            if lX&gt;lY:
                self.X=self.X[0:lY]
                lX=lY
            elif lY&gt;lX:
                self.Y=self.Y[0:lX]
                lY=lX
            if not len(self.dY):
                self.dY=zeros((lX,1))
            if not len(self.dX):
                self.dX=zeros((lX,1))

            # we scale the color scale
            self.C=(self.C-min(self.C))/(max(self.C)-min(self.C))

            # we make sure no size is non-positive
            if min(self.S)&lt;=0:
                self.S=(self.S-min(self.S))+0.001

        # and now we can make the style !
        kwargs[&#39;col&#39;]=col ; kwargs[&#39;siz&#39;]=siz ; kwargs[&#39;is_function&#39;]=self.is_function
        kwargs[&#39;numr&#39;]=self.numr ; kwargs[&#39;dx&#39;]=dx ; kwargs[&#39;dy&#39;]=dy ; kwargs[&#39;stil&#39;]=stil
        kwargs[&#39;color_from_data&#39;]=self.color_from_data
        #kwargs[&#39;is_histogram&#39;]=self.is_histogram

        style=Style(*args,**kwargs)
        self.style=style.style
        self.stroke_style=style.stroke_style

        if style.goodstyle.kind==&#39;histogram&#39;:
            self.is_histogram=1

        #if self.is_histogram:
            #self.stroke=Style(*args,**kwargs).style
            #self.stroke_style=style.stroke_style

             #self.stroke_style=Style(*args,**kwargs.style)

    def make_auto_legend(self,legend):
        &#34;&#34;&#34; A function to automatically make a legend &#34;&#34;&#34;
        if legend==&#39;None&#39; or legend==&#39;none&#39;:
            self.legend=None
        elif legend:
            self.legend=r&#34;%s&#34; %legend
        else:
            if self.function_string:
                self.legend=self.function_string
            elif self.fname:
                lenf=len(self.fname)
                if lenf&lt;=16:
                    self.legend=self.fname
            else:
                self.legend=None

    def set_init_XY(self,A):
        &#34;&#34;&#34; Initial values of X and Y, usefull to later apply conditions &#34;&#34;&#34;
        try:
            if self.mode==&#39;h&#39;:
                self.X=A[0,:]
                self.Y=A[1,:]
            else:
                self.X=A[:,0]
                self.Y=A[:,1]
        except:
            sio.custom_warn(&#39;Could not set initial X Y values before reading arguments&#39;)
        return

    def set_n_points(self,arg):
        self.n_points=200
        try:
            self.n_points=int(arg)
        except:
            raise ValueError(&#39;Did not understand npoints from input %s&#39;  %arg)

    def set_label(self,label,coord):
        &#34;&#34;&#34; sets a label for coordinate x or y &#34;&#34;&#34;
        if coord==&#39;x&#39;:
            self.xlabel=label
        elif coord==&#39;y&#39;:
            self.ylabel=label
        return

    def set_from_input(self,A,input,coord):
        &#34;&#34;&#34; Tries to compute a variable of name coord from an input, usually a string or number, using the data A&#34;&#34;&#34;
        # We first check if axis defined by a row/column number
        X=self.X;x=X
        Y=self.Y;y=Y

        if input in self.labels:
            input=self.label_dict[input]

        try :
            i=int(input)
            if self.mode==&#39;h&#39;:
                # We try auto-setting the label if no label is defined
                if i&lt;len(self.labels):
                    self.set_label(self.labels[i],coord)
                return A[i,:]
            else:
                if i&lt;len(self.labels):
                    self.set_label(self.labels[i],coord)
                return A[:,i]
        except:
            if input:
                # Automatic axis value : 1 to length of array
                if input.startswith(&#39;aut&#39;):
                    if self.mode==&#39;h&#39;:
                        return array(range(len(A[0,:])))
                    else:
                        return array(range(len(A[:,0])))
                # Interpreting axis value
                for label in self.labels:
                    # trying to substitute label to array values
                    if input.find(label)&gt;=0:
                        input=self.substitute_label(input,A,label)
                try:
                    return eval(input)
                except:
                    if not coord==&#34;color&#34;:
                        raise ValueError(&#39;We could note evaluate %s from %s&#39; %(coord,input))
                    else:
                        sio.custom_warn(&#39;We might not be able to evaluate %s from %s&#39; %(coord,input))
                    return []
            else:
                return []

    def substitute_label(self,input,A,label):
        &#34;&#34;&#34; Substitutes names by values&#34;&#34;&#34;
        i=self.label_dict[label]
        if self.mode==&#39;h&#39;:
            replace=&#39;A[%s,:]&#39; %i
        else:
            replace=&#39;A[:,%s]&#39; %i
        return input.replace(label,replace)

    def set_A_range(self,A,in_range):
        &#34;&#34;&#34; Selects only a range of data &#34;&#34;&#34;
        # first we need to make data horizontal for the range operation
        if self.mode==&#39;h&#39;:
            B=A.transpose()
        else:
            B=A.copy()
        if len(in_range)&gt;0:
            srange=in_range.split(&#34;:&#34;)
            lr=len(srange)
            try :
                iii=array([int(s) for s in srange])
                if lr==1:
                    B=array([B[iii[0]]])
                elif lr==2:
                    B=B[iii[0]:iii[1]]
                elif lr==3:
                    B=B[iii[0]:iii[2]:iii[1]]
                else:
                    #print(&#39;Range must be of the format begin:end or begin:range&#39;)
                    raise ValueError(&#39;Range must be of the format begin:end or begin:step:end&#39;)
            except:
                raise ValueError(&#39;Cannot convert Range to adequate format (note : range must be of the format begin:end or begin:step:end)&#39;)
        if self.mode==&#39;h&#39;:
            A=B.transpose()
        else:
            A=B.copy()

        return A


    def set_A_condition(self,A,cond):
        &#34;&#34;&#34; Selects data by condition &#34;&#34;&#34;
        if self.mode==&#39;h&#39;:
            B=A.transpose()
        else:
            B=A.copy()

        if len(cond)&gt;0:
            X=self.X;x=X
            Y=self.Y;y=Y
            try:
                kept=eval(cond)
                if self.mode==&#39;h&#39;:
                    B=B[kept]
                    A=B.transpose()
                else:
                    A=A[kept]
            except:
                raise ValueError(&#39;Cannot understand condition. Hint use : if=\&#39;A[:,2]&gt;0.5\&#39; &#39;)

        return A</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="seplot.grapher.Graph.make_auto_legend"><code class="name flex">
<span>def <span class="ident">make_auto_legend</span></span>(<span>self, legend)</span>
</code></dt>
<dd>
<div class="desc"><p>A function to automatically make a legend</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_auto_legend(self,legend):
    &#34;&#34;&#34; A function to automatically make a legend &#34;&#34;&#34;
    if legend==&#39;None&#39; or legend==&#39;none&#39;:
        self.legend=None
    elif legend:
        self.legend=r&#34;%s&#34; %legend
    else:
        if self.function_string:
            self.legend=self.function_string
        elif self.fname:
            lenf=len(self.fname)
            if lenf&lt;=16:
                self.legend=self.fname
        else:
            self.legend=None</code></pre>
</details>
</dd>
<dt id="seplot.grapher.Graph.set_A_condition"><code class="name flex">
<span>def <span class="ident">set_A_condition</span></span>(<span>self, A, cond)</span>
</code></dt>
<dd>
<div class="desc"><p>Selects data by condition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_A_condition(self,A,cond):
    &#34;&#34;&#34; Selects data by condition &#34;&#34;&#34;
    if self.mode==&#39;h&#39;:
        B=A.transpose()
    else:
        B=A.copy()

    if len(cond)&gt;0:
        X=self.X;x=X
        Y=self.Y;y=Y
        try:
            kept=eval(cond)
            if self.mode==&#39;h&#39;:
                B=B[kept]
                A=B.transpose()
            else:
                A=A[kept]
        except:
            raise ValueError(&#39;Cannot understand condition. Hint use : if=\&#39;A[:,2]&gt;0.5\&#39; &#39;)

    return A</code></pre>
</details>
</dd>
<dt id="seplot.grapher.Graph.set_A_range"><code class="name flex">
<span>def <span class="ident">set_A_range</span></span>(<span>self, A, in_range)</span>
</code></dt>
<dd>
<div class="desc"><p>Selects only a range of data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_A_range(self,A,in_range):
    &#34;&#34;&#34; Selects only a range of data &#34;&#34;&#34;
    # first we need to make data horizontal for the range operation
    if self.mode==&#39;h&#39;:
        B=A.transpose()
    else:
        B=A.copy()
    if len(in_range)&gt;0:
        srange=in_range.split(&#34;:&#34;)
        lr=len(srange)
        try :
            iii=array([int(s) for s in srange])
            if lr==1:
                B=array([B[iii[0]]])
            elif lr==2:
                B=B[iii[0]:iii[1]]
            elif lr==3:
                B=B[iii[0]:iii[2]:iii[1]]
            else:
                #print(&#39;Range must be of the format begin:end or begin:range&#39;)
                raise ValueError(&#39;Range must be of the format begin:end or begin:step:end&#39;)
        except:
            raise ValueError(&#39;Cannot convert Range to adequate format (note : range must be of the format begin:end or begin:step:end)&#39;)
    if self.mode==&#39;h&#39;:
        A=B.transpose()
    else:
        A=B.copy()

    return A</code></pre>
</details>
</dd>
<dt id="seplot.grapher.Graph.set_from_input"><code class="name flex">
<span>def <span class="ident">set_from_input</span></span>(<span>self, A, input, coord)</span>
</code></dt>
<dd>
<div class="desc"><p>Tries to compute a variable of name coord from an input, usually a string or number, using the data A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_from_input(self,A,input,coord):
    &#34;&#34;&#34; Tries to compute a variable of name coord from an input, usually a string or number, using the data A&#34;&#34;&#34;
    # We first check if axis defined by a row/column number
    X=self.X;x=X
    Y=self.Y;y=Y

    if input in self.labels:
        input=self.label_dict[input]

    try :
        i=int(input)
        if self.mode==&#39;h&#39;:
            # We try auto-setting the label if no label is defined
            if i&lt;len(self.labels):
                self.set_label(self.labels[i],coord)
            return A[i,:]
        else:
            if i&lt;len(self.labels):
                self.set_label(self.labels[i],coord)
            return A[:,i]
    except:
        if input:
            # Automatic axis value : 1 to length of array
            if input.startswith(&#39;aut&#39;):
                if self.mode==&#39;h&#39;:
                    return array(range(len(A[0,:])))
                else:
                    return array(range(len(A[:,0])))
            # Interpreting axis value
            for label in self.labels:
                # trying to substitute label to array values
                if input.find(label)&gt;=0:
                    input=self.substitute_label(input,A,label)
            try:
                return eval(input)
            except:
                if not coord==&#34;color&#34;:
                    raise ValueError(&#39;We could note evaluate %s from %s&#39; %(coord,input))
                else:
                    sio.custom_warn(&#39;We might not be able to evaluate %s from %s&#39; %(coord,input))
                return []
        else:
            return []</code></pre>
</details>
</dd>
<dt id="seplot.grapher.Graph.set_init_XY"><code class="name flex">
<span>def <span class="ident">set_init_XY</span></span>(<span>self, A)</span>
</code></dt>
<dd>
<div class="desc"><p>Initial values of X and Y, usefull to later apply conditions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_init_XY(self,A):
    &#34;&#34;&#34; Initial values of X and Y, usefull to later apply conditions &#34;&#34;&#34;
    try:
        if self.mode==&#39;h&#39;:
            self.X=A[0,:]
            self.Y=A[1,:]
        else:
            self.X=A[:,0]
            self.Y=A[:,1]
    except:
        sio.custom_warn(&#39;Could not set initial X Y values before reading arguments&#39;)
    return</code></pre>
</details>
</dd>
<dt id="seplot.grapher.Graph.set_label"><code class="name flex">
<span>def <span class="ident">set_label</span></span>(<span>self, label, coord)</span>
</code></dt>
<dd>
<div class="desc"><p>sets a label for coordinate x or y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_label(self,label,coord):
    &#34;&#34;&#34; sets a label for coordinate x or y &#34;&#34;&#34;
    if coord==&#39;x&#39;:
        self.xlabel=label
    elif coord==&#39;y&#39;:
        self.ylabel=label
    return</code></pre>
</details>
</dd>
<dt id="seplot.grapher.Graph.set_n_points"><code class="name flex">
<span>def <span class="ident">set_n_points</span></span>(<span>self, arg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_n_points(self,arg):
    self.n_points=200
    try:
        self.n_points=int(arg)
    except:
        raise ValueError(&#39;Did not understand npoints from input %s&#39;  %arg)</code></pre>
</details>
</dd>
<dt id="seplot.grapher.Graph.substitute_label"><code class="name flex">
<span>def <span class="ident">substitute_label</span></span>(<span>self, input, A, label)</span>
</code></dt>
<dd>
<div class="desc"><p>Substitutes names by values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def substitute_label(self,input,A,label):
    &#34;&#34;&#34; Substitutes names by values&#34;&#34;&#34;
    i=self.label_dict[label]
    if self.mode==&#39;h&#39;:
        replace=&#39;A[%s,:]&#39; %i
    else:
        replace=&#39;A[:,%s]&#39; %i
    return input.replace(label,replace)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="seplot" href="index.html">seplot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="seplot.grapher.get_histogram" href="#seplot.grapher.get_histogram">get_histogram</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="seplot.grapher.Graph" href="#seplot.grapher.Graph">Graph</a></code></h4>
<ul class="two-column">
<li><code><a title="seplot.grapher.Graph.make_auto_legend" href="#seplot.grapher.Graph.make_auto_legend">make_auto_legend</a></code></li>
<li><code><a title="seplot.grapher.Graph.set_A_condition" href="#seplot.grapher.Graph.set_A_condition">set_A_condition</a></code></li>
<li><code><a title="seplot.grapher.Graph.set_A_range" href="#seplot.grapher.Graph.set_A_range">set_A_range</a></code></li>
<li><code><a title="seplot.grapher.Graph.set_from_input" href="#seplot.grapher.Graph.set_from_input">set_from_input</a></code></li>
<li><code><a title="seplot.grapher.Graph.set_init_XY" href="#seplot.grapher.Graph.set_init_XY">set_init_XY</a></code></li>
<li><code><a title="seplot.grapher.Graph.set_label" href="#seplot.grapher.Graph.set_label">set_label</a></code></li>
<li><code><a title="seplot.grapher.Graph.set_n_points" href="#seplot.grapher.Graph.set_n_points">set_n_points</a></code></li>
<li><code><a title="seplot.grapher.Graph.substitute_label" href="#seplot.grapher.Graph.substitute_label">substitute_label</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>